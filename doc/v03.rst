
==================
Version 3 Refactor
==================

Abstract Goals:

* Absolute configuration compatibility (upward compatible.)
  including all plugins.

* multi-protocol support.
  ability to put in urls for mqtt, or different amqp libraries, perhaps others.

* internally represent things in v03 messages, have something build
  v02 ones for compatibility, but operate in v03.

* less code, simpler code.
  more readable, elegant, pythonic code.
  make maintenance easier. 

while you're at it
------------------

goals of opportunity:

  * add stuff to make it work as an API?
  * potentially new plugin api to allow groups (of messages and/or files.)
  * Finish off log rotation.
  * Assume python >= 3.4 remove old cruft.
  * Assume ubuntu >= 18.04 remove old cruft.
  * Assume systemd, remove sysv integration.
 
Uknowns
-------

Things that are not clear at the outset.


Ship of Theseus
~~~~~~~~~~~~~~~

It might be that the re-factoring inherent in v03 results in a 
Ship of Theseus, where it works the same way as v02, but all
the parts are different... obviously a concern/risk... 
might be a feature.

Dictionaries or Members for Properties?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

There seems to be a tension between using class members and dictionaries
for settings.  members seem more convenient, but harder to manipulate,
though we have equivalent idioms. Argparse returns options as their own
members of this parsing object.  There is a hierarchy to reconcile:

* protocol defaults
* consumer defaults
* component defaults
* configuration settings (overrides)
* command line options (overrides)

resolving them to apply overrides, mais more sense as operations
on dictionaries, printing, saving loading, again makes more sense
as dictionaries.  In code, members are slightly shorter, and perhaps
more idiomatic:: 

   hasattr(cfg,'member') vs. 'member' in cfg (dictionary)

What makes more sense... Does it make any practical difference?
not sure... need to keep the members for places where
plugins are called, but can use properties elsewhere, if desired.

Known Problems
--------------

* passing of logs around is really odd. we didn't understand what 
  python logging objects were. Need to use them in the normal way.
  new modules are built that way...

* this weird try/except thing for importing modules... tried removing
  it but it broke parsing of checksums... sigh... have to spend time
  on specifically that problem. On new modules ( sarra.config, 
  sarra.tmpc.*, sr.py ) using normal imports. likely need to
  refactor how checksum plugin mechanism works then try again.


Concrete Plan
-------------

replace sarra/sr_config with sarra/sr_cfg2. The new sr_cfg2 uses argparse 
and a simpler model for config file parsing.

make sr.py accept operations on subsets, so it becomes the unique entry point.
internalize implementation of all management stuff, declare etc...

HMPC - Topic Message Protocol Client... a generalization of the message
passing library with a simplified API.  abstracts the protocol differences
away.


Progress
--------

The functionality of sr_amqp.py is completely reproduced in TMPC/amqp.py 
(but not yet used, except by sr.py.) All the important logic is preserved, 
but it is transcribed into new classes. Should have identical 
failure recovery behaviour.  This is working in a demo form. To 
reproduce, fire up sr_insects, run setup. and the configurations will 
be installed.

sr_cfg2.py is still a stub, it has a lot of features and options, but
it isn't clear how to expand it to all of them. the thing about instances
inheriting from configure... it is odd, but hard to see how changing that
will not break everything, plugin-wise... thinking about having defaults
distributed to the classes that use the settings, and having something
that brings them together, instead of one massive config thing.
renamed to config.py (aka: sarra.config) and exercising it with
sr.py.

Thinking about replacing sr_consumer with a new class that implements the
General Algorithm describe in `Concepts <Concepts.rst#the-general-algorithm>`

Thinking about just removing the sr_ prefix from classes for replacements,
since they are in sarra directory anyways. so have an internal class 
sarra/instances, sarra/sarra <- replace consumer...

Added configuration selection to sr.py (e.g. subscribe/\*) and 
*setup*, and *cleanup* options. 

add/remove/enable/disable/edit done.

'log' dropped for now... (which log ?)

added list, show, and built prototype shovel... required
a instance (sets state files and logs) and then calls flow... 
flow/run() is visibly  the general algorithm,
shovel is a sub-class of flow.

Got a skeleton for v2 plugins working (v2wrapper.py)
implemented import-based and group oriented v3 plugin framework. ( #213 )

cache (no called noDupe) is basically working.

re-wrote how the v3 plugins work to use worklists, and then re-cast
cache and v2plugins as plugins themselves.

renamed message queue abstract class from tmpc to moth
(what does sarracenia eat?)





FIXME
-----

FIXME are things left to the side that need to be seen to.

* changed behaviour of 'sr list' , 'sr list examples' needs to be documented.

* new command 'sr show' needs to be documented. 

* scopable properties for internal classes, like they exist for plugins.

Incompatibilities
-----------------

There are not supposed to be any.  This is a running list of things to fix or document.
breaking changes:

* loglevel none -> loglevel notset (now passing loglevel setting directly to python logging module, none isn't defined.)

* log messages and output in interactive, will be completely different.


Features
--------

* sarra.plugin API is now vanilla python with no magic settings. just standard classes, using standard import mechanism.
  debugging should be much simpler now as the interpreter will provide much better error messages on startup.

* properties/options for classes are now hierarchical, so can set debug to specific classes within app.

* sarra.moth class abstracts away AMQP, so messaging protocol becomes pluggable.

* use the sarra. prefix (already present) so remove obsolete sr_ prefix on modules.

* API access to flows.

* sr ability to select multiple components and configurations to operate on.

* messages are acknowledged more quickly, should help with throughput.

* plugin API are now based on groups of messages, rather than individual ones, allowing people
  to organize concurrent work.


